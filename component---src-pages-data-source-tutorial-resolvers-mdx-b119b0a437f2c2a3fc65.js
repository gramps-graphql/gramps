(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{384:function(e,t,a){"use strict";a.r(t),a.d(t,"_frontmatter",(function(){return s})),a.d(t,"default",(function(){return p}));a(11),a(5),a(6),a(2),a(10),a(1),a(0);var n=a(103),r=a(395);function o(){return(o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var n in a)Object.prototype.hasOwnProperty.call(a,n)&&(e[n]=a[n])}return e}).apply(this,arguments)}var s={},l=function(e){return function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),Object(n.b)("div",t)}},i=l("AnchorLinks"),c=l("AnchorLink"),b={_frontmatter:s},d=r.a;function p(e){var t=e.components,a=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,["components"]);return Object(n.b)(d,o({},b,a,{components:t,mdxType:"MDXLayout"}),Object(n.b)("p",null,"Now we know how to get data thanks to our ",Object(n.b)("a",o({parentName:"p"},{href:"/data-source-tutorial/connector"}),"connector")," and ",Object(n.b)("a",o({parentName:"p"},{href:"/data-source-tutorial/model"}),"model"),", and have told GraphQL clients what kind of data to expect with our ",Object(n.b)("a",o({parentName:"p"},{href:"/data-source-tutorial/schema"}),"schema"),". In this section, we’ll add resolver functions to map the API response to our schema so we can actually return data."),Object(n.b)("h2",{id:"table-of-contents"},"Table of Contents"),Object(n.b)("ul",null,Object(n.b)("li",{parentName:"ul"},Object(n.b)("a",o({parentName:"li"},{href:"/data-source-tutorial/setup"}),"Initial Data Source Setup")),Object(n.b)("li",{parentName:"ul"},Object(n.b)("a",o({parentName:"li"},{href:"/data-source-tutorial/connector"}),"Create a Connector")),Object(n.b)("li",{parentName:"ul"},Object(n.b)("a",o({parentName:"li"},{href:"/data-source-tutorial/model"}),"Create a Model")),Object(n.b)("li",{parentName:"ul"},Object(n.b)("a",o({parentName:"li"},{href:"/data-source-tutorial/schema"}),"Write a GraphQL Schema")),Object(n.b)("li",{parentName:"ul"},Object(n.b)("strong",{parentName:"li"},"> ",Object(n.b)("a",o({parentName:"strong"},{href:"/data-source-tutorial/resolvers"}),"Write Resolvers"))),Object(n.b)("li",{parentName:"ul"},Object(n.b)("a",o({parentName:"li"},{href:"/data-source-tutorial/dev"}),"Use Development Modes"))),Object(n.b)("h2",{id:"in-this-section"},"In This Section"),Object(n.b)(i,{mdxType:"AnchorLinks"},Object(n.b)(c,{mdxType:"AnchorLink"},"Write Query Resolvers"),Object(n.b)(c,{mdxType:"AnchorLink"},"Test the Query Resolvers"),Object(n.b)(c,{mdxType:"AnchorLink"},"Add Mock Data Resolvers for Development"),Object(n.b)(c,{mdxType:"AnchorLink"},"Test the Mock Data Resolvers"),Object(n.b)(c,{mdxType:"AnchorLink"},"Add Real Data Resolvers for Fields That Require Them"),Object(n.b)(c,{mdxType:"AnchorLink"},"Test the Data Resolvers")),Object(n.b)("h2",{id:"write-query-resolvers"},"Write Query Resolvers"),Object(n.b)("p",null,"The first thing we need to do is to tell GraphQL which model method should be called when a query is made. In ",Object(n.b)("inlineCode",{parentName:"p"},"src/resolvers.js"),", update the query resolver to call our movie search method:"),Object(n.b)("pre",null,Object(n.b)("code",o({parentName:"pre"},{className:"language-diff"}),"  export default {\n    queryResolvers: {\n-     // TODO: Update query resolver name(s) to match schema queries\n-     YourDataSource: (rootValue, { id }, context) =>\n+     searchMoviesByTitle: (_, { options }, context) =>\n        new Promise((resolve, reject) => {\n-         // TODO: Update to use the model and call the proper method.\n-         context.YourDataSource\n-           .getById(id)\n+         context.IMDBAPI\n+           .searchMoviesByTitle(options)\n            .then(resolve)\n            .catch(reject);\n        }),\n    },\n")),Object(n.b)("p",null,"Rememember that ","[we provided a name for the ",Object(n.b)("inlineCode",{parentName:"p"},"context"),"]","({{ site.github.url }}/data-source/tutorial-setup/#update-the-context-name-for-the-data-source) in ",Object(n.b)("inlineCode",{parentName:"p"},"src/index.js"),", which is now used to refer to our model."),Object(n.b)("blockquote",null,Object(n.b)("p",{parentName:"blockquote"},Object(n.b)("strong",{parentName:"p"},"NOTE:")," We don’t actually use the first argument to the query resolver\nbecause its original function has been replaced by the ",Object(n.b)("inlineCode",{parentName:"p"},"context")," argument.\nUsing ",Object(n.b)("inlineCode",{parentName:"p"},"_")," is a convention to signify that an argument is unused.")),Object(n.b)("h2",{id:"test-the-query-resolvers"},"Test the Query Resolvers"),Object(n.b)("p",null,"One of the great things about the Apollo server is that resolvers are pure functions. This means that they’re not terribly hard to test, despite the fact that they’re used to load data."),Object(n.b)("p",null,"To start, let’s remove the example tests from ",Object(n.b)("inlineCode",{parentName:"p"},"test/resolvers.test.js"),":"),Object(n.b)("pre",null,Object(n.b)("code",o({parentName:"pre"},{className:"language-diff"}),"    describe('queryResolvers', () => {\n-     describe(DATA_SOURCE_NAME, () => {\n-       it('loads a thing by its ID', () => {\n-         expect.assertions(1);\n-\n-         const req = {};\n-\n-         // TODO: Update with mock arguments for your model method.\n-         const args = { id: 'abc1234' };\n-\n-         // TODO: Update with the data source model name and method(s).\n-         const mockContext = {\n-           YourDataSource: {\n-             // For testing, we mock the model to simply return the ID.\n-             getById: id => Promise.resolve(id),\n-           },\n-         };\n-\n-         return expect(\n-           // TODO: Update to use your data source.\n-           resolvers.queryResolvers.YourDataSource(req, args, mockContext),\n-         ).resolves.toEqual('abc1234');\n-       });\n-     });\n    });\n")),Object(n.b)("p",null,"In its place, let’s add a new test for ",Object(n.b)("inlineCode",{parentName:"p"},"searchMoviesByTitle()"),"."),Object(n.b)("p",null,"Before we write the test, we need to mock the context. Since unit tests should only test one unit of code at a time (e.g. this query resolver function), we’re going to mock the response from our connector method so it just returns a resolved Promise with the arguments that were provided to it. We do this so it’s easy to test whether or not the query resolver is asking for the correct data."),Object(n.b)("pre",null,Object(n.b)("code",o({parentName:"pre"},{className:"language-diff"}),"    describe('queryResolvers', () => {\n+     const mockContext = {\n+       IMDBAPI: {\n+         searchMoviesByTitle: queryArgs => Promise.resolve(queryArgs),\n+       },\n+     };\n    });\n")),Object(n.b)("p",null,"With the mock context read, we can set up a test for ",Object(n.b)("inlineCode",{parentName:"p"},"searchMoviesByDefault()")," that makes a call to the query resolver using our mock context and a properly formed ",Object(n.b)("inlineCode",{parentName:"p"},"options")," object — remember that it requires a ",Object(n.b)("inlineCode",{parentName:"p"},"title")," and optionally accepts a ",Object(n.b)("inlineCode",{parentName:"p"},"year")," — and expects that the connector method will be called with the contents of ",Object(n.b)("inlineCode",{parentName:"p"},"options"),"."),Object(n.b)("p",null,"Add the following t"),Object(n.b)("pre",null,Object(n.b)("code",o({parentName:"pre"},{className:"language-diff"}),"    describe('queryResolvers', () => {\n      const mockContext = {\n        IMDBAPI: {\n          searchMoviesByTitle: queryArgs => Promise.resolve(queryArgs),\n        },\n      };\n\n+     describe('searchMoviesByTitle()', () => {\n+       it('searches for movies by their titles', async () => {\n+         expect.assertions(1);\n+\n+         const args = { options: { title: 'Test Movie' } };\n+         const response = await resolvers.queryResolvers.searchMoviesByTitle(\n+           null,\n+           args,\n+           mockContext,\n+         );\n+\n+         return expect(response).toEqual({ title: 'Test Movie' });\n+       });\n+     });\n    });\n")),Object(n.b)("h2",{id:"add-mock-data-resolvers-for-development"},"Add Mock Data Resolvers for Development"),Object(n.b)("p",null,"One of the most powerful development tools offered by GraphQL is the ability to very easily mock data. This means that developers can work on a front end and back end simultaneously, as long as everyone’s agreed on what the data will look like at the end."),Object(n.b)("p",null,"To take advantage of this, we’ll want to add mock resolvers. Without a mock resolver, all ",Object(n.b)("inlineCode",{parentName:"p"},"String")," fields return ",Object(n.b)("inlineCode",{parentName:"p"},"Hello World"),", which isn’t very useful for testing in many cases. We’ll use a helper library called ",Object(n.b)("a",o({parentName:"p"},{href:"https://www.npmjs.com/package/casual"}),Object(n.b)("inlineCode",{parentName:"a"},"casual"))," to solve this, which generates more realistic mock data in useful formats like names, address info, dates, and more."),Object(n.b)("p",null,"Add the following mock resolvers to ",Object(n.b)("inlineCode",{parentName:"p"},"src/resolvers.js"),":"),Object(n.b)("pre",null,Object(n.b)("code",o({parentName:"pre"},{className:"language-diff"}),"    mockResolvers: {\n-     // TODO: Update to mock all schema fields and types.\n-     PFX_YourDataSource: () => ({\n-       id: casual.uuid,\n-       name: casual.name,\n-       lucky_numbers: () => new MockList([0, 3]),\n-     }),\n+     IMDB_Movie: () => ({\n+       cast: () => new MockList([1, 10]),\n+       content_rating: casual.random_element(['PG', 'R', 'PG-13']),\n+       description: casual.sentences(2),\n+       director: casual.name,\n+       genre: () =>\n+         new MockList([1, 3], () =>\n+           casual.random_element(['Action', 'Drama', 'Comedy']),\n+         ),\n+       imdb_id: `tt${Math.round(10000000 * Math.random())}`,\n+       length: `${casual.integer(75, 190)}`,\n+       original_title: casual.title,\n+       rating: casual.integer(0, 100) / 10,\n+       rating_count: casual.integer(0, 300),\n+       release_date: casual.date('YYYY-MM-DD'),\n+       stars: () => new MockList([1, 4], () => casual.name),\n+       storyline: casual.sentences(2),\n+       title: casual.title,\n+       trailer: () => new MockList([1, 3]),\n+       writers: () => new MockList([1, 4], () => casual.name),\n+       year: casual.year,\n+     }),\n    },\n")),Object(n.b)("blockquote",null,Object(n.b)("p",{parentName:"blockquote"},Object(n.b)("strong",{parentName:"p"},"NOTE:")," For fields that return an array that may vary in length (for\nexample, the number of cast members), we can use Apollo’s ",Object(n.b)("a",o({parentName:"p"},{href:"http://dev.apollodata.com/tools/graphql-tools/mocking.html#Using-MockList-in-resolvers"}),Object(n.b)("inlineCode",{parentName:"a"},"MockList")),"\nhelper to provide a random-length array. ",Object(n.b)("a",o({parentName:"p"},{href:"http://dev.apollodata.com/tools/graphql-tools/mocking.html#Using-MockList-in-resolvers"}),"See the docs")," for more info.")),Object(n.b)("h2",{id:"test-the-mock-data-resolvers"},"Test the Mock Data Resolvers"),Object(n.b)("p",null,"Because we don’t actually know (or care) about the ",Object(n.b)("em",{parentName:"p"},"actual")," response from a mock field (e.g. it doesn’t matter if a mocked name is “Mr. Bentley Tubbinsworth” or “Mrs. Roo Fluffkins”), we’re going to test that:"),Object(n.b)("ol",null,Object(n.b)("li",{parentName:"ol"},"The correct mock fields are returned by the mock resolver"),Object(n.b)("li",{parentName:"ol"},"Fields that should return a ",Object(n.b)("inlineCode",{parentName:"li"},"MockList")," are actually returning ",Object(n.b)("inlineCode",{parentName:"li"},"MockList"),"s"),Object(n.b)("li",{parentName:"ol"},Object(n.b)("inlineCode",{parentName:"li"},"MockList"),"s with custom values are behaving as expected")),Object(n.b)("p",null,"To test that the correct fields are returned, we’re going to use the ","[",Object(n.b)("inlineCode",{parentName:"p"},"expectMockFields()")," test helper]","({{ site.github.url }}/api/testing/#expectmockfieldsresolver-fieldarray)."),Object(n.b)("p",null,"To test ",Object(n.b)("inlineCode",{parentName:"p"},"MockList"),"s, we’ll use the ","[",Object(n.b)("inlineCode",{parentName:"p"},"expectMockList()")," test helper]","({{ site.github.url }}/api/testing/#expectmocklistresolver-fieldarray)"),Object(n.b)("p",null,"Add the following to ",Object(n.b)("inlineCode",{parentName:"p"},"test/resolvers.test.js"),":"),Object(n.b)("pre",null,Object(n.b)("code",o({parentName:"pre"},{className:"language-diff"}),"    describe('mockResolvers', () => {\n+     describe('IMDB_Movie', () => {\n+       const mockResolvers = resolvers.mockResolvers.IMDB_Movie();\n+\n+       expectMockFields(mockResolvers, [\n+         'cast',\n+         'content_rating',\n+         'description',\n+         'director',\n+         'genre',\n+         'imdb_id',\n+         'length',\n+         'original_title',\n+         'rating',\n+         'rating_count',\n+         'release_date',\n+         'stars',\n+         'storyline',\n+         'title',\n+         'trailer',\n+         'writers',\n+         'year',\n+       ]);\n+\n+       expectMockList(mockResolvers, [\n+         'cast',\n+         'genre',\n+         'stars',\n+         'trailer',\n+         'writers',\n+       ]);\n+\n+       it('mocks the genre', () => {\n+         expect(\n+           ['Action', 'Drama', 'Comedy'].includes(\n+             mockResolvers.genre().wrappedFunction(),\n+           ),\n+         ).toBe(true);\n+       });\n+\n+       it('mocks the stars', () => {\n+         expect(mockResolvers.stars().wrappedFunction()).toBeDefined();\n+       });\n+\n+       it('mocks the writers', () => {\n+         expect(mockResolvers.writers().wrappedFunction()).toBeDefined();\n+       });\n+     });\n    });\n")),Object(n.b)("blockquote",null,Object(n.b)("p",{parentName:"blockquote"},Object(n.b)("strong",{parentName:"p"},"NOTE:")," The use of ",Object(n.b)("inlineCode",{parentName:"p"},"wrappedFunction()")," is a way to get at what the\n",Object(n.b)("inlineCode",{parentName:"p"},"MockList")," returns for a single entry, which allows us to test the value.")),Object(n.b)("h2",{id:"add-real-data-resolvers-for-fields-that-require-them"},"Add Real Data Resolvers for Fields That Require Them"),Object(n.b)("p",null,"When we’re using live data, we don’t need to do anything in most cases: the default behavior of GraphQL is to look for a field in the data object that matches the field name in the schema, meaning this schema:"),Object(n.b)("pre",null,Object(n.b)("code",o({parentName:"pre"},{className:"language-graphql"}),"type PFX_Person {\n  name: String!\n  company: String!\n}\n")),Object(n.b)("p",null,"And this data response:"),Object(n.b)("pre",null,Object(n.b)("code",o({parentName:"pre"},{className:"language-json"}),'{\n  "name": "Jason Lengstorf",\n  "company": "IBM"\n}\n')),Object(n.b)("p",null,"Will work as-is, with no data resolvers required."),Object(n.b)("p",null,"That means that for our IMDB API data source, there’s only one field that requires a data resolver: the ",Object(n.b)("inlineCode",{parentName:"p"},"asp_ratio")," field that’s misspelled in the API response."),Object(n.b)("p",null,"Let’s add that resolver to ",Object(n.b)("inlineCode",{parentName:"p"},"src/resolvers.js"),":"),Object(n.b)("pre",null,Object(n.b)("code",o({parentName:"pre"},{className:"language-diff"}),"    dataResolvers: {\n-     // TODO: Update to reference the schema type(s) and field(s).\n-     PFX_YourDataSource: {\n-       // If a field isn’t always set, but it shouldn’t break the response, make it nullable.\n-       name: data => data.name || null,\n-     },\n+     IMDB_Metadata: {\n+       // Alias this field to fix a typo.\n+       asp_ratio: data => data.asp_retio,\n+     },\n    },\n")),Object(n.b)("h2",{id:"test-the-data-resolvers"},"Test the Data Resolvers"),Object(n.b)("p",null,"To test the resolver, we need to make sure that it provides the expected value when given an object with the expected data. We get to see the power of using pure functions here again, because all we have to do is give our resolver an object and test what it returns."),Object(n.b)("p",null,"Let’s add it by making the following changes in ",Object(n.b)("inlineCode",{parentName:"p"},"test/resolvers.test.js"),":"),Object(n.b)("pre",null,Object(n.b)("code",o({parentName:"pre"},{className:"language-diff"}),"    describe('dataResolvers', () => {\n-     describe('PFX_YourDataSource', () => {\n-       const resolver = resolvers.dataResolvers.PFX_YourDataSource;\n-\n-       expectNullable(resolver, ['name']);\n-     });\n+     describe('IMDB_Metadata', () => {\n+       const resolver = resolvers.dataResolvers.IMDB_Metadata;\n+\n+       it('fixes the typo for the aspect ratio', () => {\n+         expect(resolver.asp_ratio({ asp_retio: '16 : 9' })).toEqual('16 : 9');\n+       });\n+     });\n    });\n")),Object(n.b)("h2",{id:"next-up-use-development-modes"},"Next Up: Use Development Modes"),Object(n.b)("p",null,"At this point, we’ve got a fully functional data source — now we’re ready to test it out."))}p.isMDXComponent=!0},393:function(e){e.exports=JSON.parse('{"data":{"site":{"pathPrefix":""}}}')},394:function(e){e.exports=JSON.parse('{"data":{"site":{"siteMetadata":{"repository":{"baseUrl":"","subDirectory":""}}}}}')},395:function(e,t,a){"use strict";a(35),a(27);var n=a(1),r=a(393),o=a(0),s=a.n(o),l=a(102),i=a.n(l),c=a(188),b=a(121),d=a(3),p=a.n(d),u=a(373),m=function(e){var t,a=e.title,r=e.tabs,o=void 0===r?[]:r;return Object(n.b)("div",{className:p()(u.pageHeader,(t={},t[u.withTabs]=o.length,t))},Object(n.b)("div",{className:"bx--grid"},Object(n.b)("div",{className:"bx--row"},Object(n.b)("div",{className:"bx--col-lg-12"},Object(n.b)("h1",{id:"page-title",className:u.text},a)))))},h=a(394),O=a(374),j=function(e){var t=e.relativePagePath,a=e.repository,r=h.data.site.siteMetadata.repository,o=a||r,s=o.baseUrl,l=s+"/tree/master"+o.subDirectory+"/src/pages"+t;return s?Object(n.b)("div",{className:"bx--row "+O.row},Object(n.b)("div",{className:"bx--col"},Object(n.b)("a",{className:O.link,href:l},"Edit this page on GitHub"))):null},v=a(186),f=a(28),g=a(375);var y=function(e){var t,a;function r(){return e.apply(this,arguments)||this}return a=e,(t=r).prototype=Object.create(a.prototype),t.prototype.constructor=t,t.__proto__=a,r.prototype.render=function(){var e=this.props,t=e.tabs,a=e.slug,r=a.split("/").filter(Boolean).slice(-1)[0],o=t.map((function(e){var t,o=i()(e,{lower:!0}),s=o===r,l=a.replace(r,o);return Object(n.b)("li",{key:e,className:p()((t={},t[g.selectedItem]=s,t),g.listItem)},Object(n.b)(f.Link,{className:g.link,to:""+l},e))}));return Object(n.b)("div",{className:g.tabsContainer},Object(n.b)("div",{className:"bx--grid"},Object(n.b)("div",{className:"bx--row"},Object(n.b)("div",{className:"bx--col-lg-12 bx--col-no-gutter"},Object(n.b)("nav",null,Object(n.b)("ul",{className:g.list},o))))))},r}(s.a.Component),k=a(187);t.a=function(e){var t=e.pageContext,a=e.children,o=e.location,s=t.frontmatter,l=void 0===s?{}:s,d=t.relativePagePath,p=t.titleType,u=l.tabs,h=l.title,O=l.theme,f=l.description,g=l.keywords,w=r.data.site.pathPrefix,N=w?o.pathname.replace(w,""):o.pathname,x=u?N.split("/").slice(-1)[0]||i()(u[0],{lower:!0}):"";return Object(n.b)(b.a,{homepage:!1,theme:O,pageTitle:h,pageDescription:f,pageKeywords:g,titleType:p},Object(n.b)(m,{title:h,label:"label",tabs:u}),u&&Object(n.b)(y,{slug:N,tabs:u,currentTab:x}),Object(n.b)(k.a,{padded:!0},a,Object(n.b)(j,{relativePagePath:d})),Object(n.b)(v.a,{pageContext:t,location:o,slug:N,tabs:u,currentTab:x}),Object(n.b)(c.a,null))}}}]);
//# sourceMappingURL=component---src-pages-data-source-tutorial-resolvers-mdx-b119b0a437f2c2a3fc65.js.map