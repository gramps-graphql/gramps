{"version":3,"sources":["webpack:///./src/pages/data-source-tutorial/resolvers.mdx","webpack:///./node_modules/gatsby-theme-carbon/src/components/PageHeader/index.js","webpack:///./node_modules/gatsby-theme-carbon/src/components/PageHeader/PageHeader.js","webpack:///./node_modules/gatsby-theme-carbon/src/components/EditLink/index.js","webpack:///./node_modules/gatsby-theme-carbon/src/components/EditLink/EditLink.js","webpack:///./node_modules/gatsby-theme-carbon/src/components/PageTabs/index.js","webpack:///./node_modules/gatsby-theme-carbon/src/components/PageTabs/PageTabs.js","webpack:///./node_modules/gatsby-theme-carbon/src/templates/Default.js"],"names":["_frontmatter","makeShortcode","name","props","console","warn","AnchorLinks","AnchorLink","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","mdxType","parentName","isMDXComponent","PageHeader","title","tabs","className","cx","pageHeader","withTabs","length","id","text","EditLink","relativePagePath","repositoryProp","repository","site","siteMetadata","baseUrl","href","subDirectory","row","link","PageTabs","render","this","slug","currentTab","split","filter","Boolean","slice","pageTabs","map","tab","slugifiedTab","slugify","lower","selected","replace","key","selectedItem","listItem","to","tabsContainer","list","React","Component","Default","pageContext","children","location","frontmatter","titleType","theme","description","keywords","pathPrefix","pathname","Layout","homepage","pageTitle","pageDescription","pageKeywords","label","Main","padded","NextPrevious","BackToTopBtn"],"mappings":"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","file":"component---src-pages-data-source-tutorial-resolvers-mdx-699bb28c8e80f4e2f2bf.js","sourcesContent":["import React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/travis/build/gramps-graphql/gramps/docs/node_modules/gatsby-theme-carbon/src/templates/Default.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst AnchorLinks = makeShortcode(\"AnchorLinks\");\nconst AnchorLink = makeShortcode(\"AnchorLink\");\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <p>{`Now we know how to get data thanks to our `}<a parentName=\"p\" {...{\n        \"href\": \"/data-source-tutorial/connector\"\n      }}>{`connector`}</a>{` and `}<a parentName=\"p\" {...{\n        \"href\": \"/data-source-tutorial/model\"\n      }}>{`model`}</a>{`, and have told GraphQL clients what kind of data to expect with our `}<a parentName=\"p\" {...{\n        \"href\": \"/data-source-tutorial/schema\"\n      }}>{`schema`}</a>{`. In this section, we’ll add resolver functions to map the API response to our schema so we can actually return data.`}</p>\n    <h2 {...{\n      \"id\": \"table-of-contents\"\n    }}>{`Table of Contents`}</h2>\n    <ul>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"/data-source-tutorial/setup\"\n        }}>{`Initial Data Source Setup`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"/data-source-tutorial/connector\"\n        }}>{`Create a Connector`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"/data-source-tutorial/model\"\n        }}>{`Create a Model`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"/data-source-tutorial/schema\"\n        }}>{`Write a GraphQL Schema`}</a></li>\n      <li parentName=\"ul\"><strong parentName=\"li\">{`> `}<a parentName=\"strong\" {...{\n            \"href\": \"/data-source-tutorial/resolvers\"\n          }}>{`Write Resolvers`}</a></strong></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"/data-source-tutorial/dev\"\n        }}>{`Use Development Modes`}</a></li>\n    </ul>\n    <h2 {...{\n      \"id\": \"in-this-section\"\n    }}>{`In This Section`}</h2>\n    <AnchorLinks mdxType=\"AnchorLinks\">\n  <AnchorLink mdxType=\"AnchorLink\">Write Query Resolvers</AnchorLink>\n  <AnchorLink mdxType=\"AnchorLink\">Test the Query Resolvers</AnchorLink>\n  <AnchorLink mdxType=\"AnchorLink\">Add Mock Data Resolvers for Development</AnchorLink>\n  <AnchorLink mdxType=\"AnchorLink\">Test the Mock Data Resolvers</AnchorLink>\n  <AnchorLink mdxType=\"AnchorLink\">Add Real Data Resolvers for Fields That Require Them</AnchorLink>\n  <AnchorLink mdxType=\"AnchorLink\">Test the Data Resolvers</AnchorLink>\n    </AnchorLinks>\n    <h2 {...{\n      \"id\": \"write-query-resolvers\"\n    }}>{`Write Query Resolvers`}</h2>\n    <p>{`The first thing we need to do is to tell GraphQL which model method should be called when a query is made. In `}<inlineCode parentName=\"p\">{`src/resolvers.js`}</inlineCode>{`, update the query resolver to call our movie search method:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-diff\"\n      }}>{`  export default {\n    queryResolvers: {\n-     // TODO: Update query resolver name(s) to match schema queries\n-     YourDataSource: (rootValue, { id }, context) =>\n+     searchMoviesByTitle: (_, { options }, context) =>\n        new Promise((resolve, reject) => {\n-         // TODO: Update to use the model and call the proper method.\n-         context.YourDataSource\n-           .getById(id)\n+         context.IMDBAPI\n+           .searchMoviesByTitle(options)\n            .then(resolve)\n            .catch(reject);\n        }),\n    },\n`}</code></pre>\n    <p>{`Rememember that `}{`[we provided a name for the `}<inlineCode parentName=\"p\">{`context`}</inlineCode>{`]`}{`({{ site.github.url }}/data-source/tutorial-setup/#update-the-context-name-for-the-data-source) in `}<inlineCode parentName=\"p\">{`src/index.js`}</inlineCode>{`, which is now used to refer to our model.`}</p>\n    <blockquote>\n      <p parentName=\"blockquote\"><strong parentName=\"p\">{`NOTE:`}</strong>{` We don’t actually use the first argument to the query resolver\nbecause its original function has been replaced by the `}<inlineCode parentName=\"p\">{`context`}</inlineCode>{` argument.\nUsing `}<inlineCode parentName=\"p\">{`_`}</inlineCode>{` is a convention to signify that an argument is unused.`}</p>\n    </blockquote>\n    <h2 {...{\n      \"id\": \"test-the-query-resolvers\"\n    }}>{`Test the Query Resolvers`}</h2>\n    <p>{`One of the great things about the Apollo server is that resolvers are pure functions. This means that they’re not terribly hard to test, despite the fact that they’re used to load data.`}</p>\n    <p>{`To start, let’s remove the example tests from `}<inlineCode parentName=\"p\">{`test/resolvers.test.js`}</inlineCode>{`:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-diff\"\n      }}>{`    describe('queryResolvers', () => {\n-     describe(DATA_SOURCE_NAME, () => {\n-       it('loads a thing by its ID', () => {\n-         expect.assertions(1);\n-\n-         const req = {};\n-\n-         // TODO: Update with mock arguments for your model method.\n-         const args = { id: 'abc1234' };\n-\n-         // TODO: Update with the data source model name and method(s).\n-         const mockContext = {\n-           YourDataSource: {\n-             // For testing, we mock the model to simply return the ID.\n-             getById: id => Promise.resolve(id),\n-           },\n-         };\n-\n-         return expect(\n-           // TODO: Update to use your data source.\n-           resolvers.queryResolvers.YourDataSource(req, args, mockContext),\n-         ).resolves.toEqual('abc1234');\n-       });\n-     });\n    });\n`}</code></pre>\n    <p>{`In its place, let’s add a new test for `}<inlineCode parentName=\"p\">{`searchMoviesByTitle()`}</inlineCode>{`.`}</p>\n    <p>{`Before we write the test, we need to mock the context. Since unit tests should only test one unit of code at a time (e.g. this query resolver function), we’re going to mock the response from our connector method so it just returns a resolved Promise with the arguments that were provided to it. We do this so it’s easy to test whether or not the query resolver is asking for the correct data.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-diff\"\n      }}>{`    describe('queryResolvers', () => {\n+     const mockContext = {\n+       IMDBAPI: {\n+         searchMoviesByTitle: queryArgs => Promise.resolve(queryArgs),\n+       },\n+     };\n    });\n`}</code></pre>\n    <p>{`With the mock context read, we can set up a test for `}<inlineCode parentName=\"p\">{`searchMoviesByDefault()`}</inlineCode>{` that makes a call to the query resolver using our mock context and a properly formed `}<inlineCode parentName=\"p\">{`options`}</inlineCode>{` object — remember that it requires a `}<inlineCode parentName=\"p\">{`title`}</inlineCode>{` and optionally accepts a `}<inlineCode parentName=\"p\">{`year`}</inlineCode>{` — and expects that the connector method will be called with the contents of `}<inlineCode parentName=\"p\">{`options`}</inlineCode>{`.`}</p>\n    <p>{`Add the following t`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-diff\"\n      }}>{`    describe('queryResolvers', () => {\n      const mockContext = {\n        IMDBAPI: {\n          searchMoviesByTitle: queryArgs => Promise.resolve(queryArgs),\n        },\n      };\n\n+     describe('searchMoviesByTitle()', () => {\n+       it('searches for movies by their titles', async () => {\n+         expect.assertions(1);\n+\n+         const args = { options: { title: 'Test Movie' } };\n+         const response = await resolvers.queryResolvers.searchMoviesByTitle(\n+           null,\n+           args,\n+           mockContext,\n+         );\n+\n+         return expect(response).toEqual({ title: 'Test Movie' });\n+       });\n+     });\n    });\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"add-mock-data-resolvers-for-development\"\n    }}>{`Add Mock Data Resolvers for Development`}</h2>\n    <p>{`One of the most powerful development tools offered by GraphQL is the ability to very easily mock data. This means that developers can work on a front end and back end simultaneously, as long as everyone’s agreed on what the data will look like at the end.`}</p>\n    <p>{`To take advantage of this, we’ll want to add mock resolvers. Without a mock resolver, all `}<inlineCode parentName=\"p\">{`String`}</inlineCode>{` fields return `}<inlineCode parentName=\"p\">{`Hello World`}</inlineCode>{`, which isn’t very useful for testing in many cases. We’ll use a helper library called `}<a parentName=\"p\" {...{\n        \"href\": \"https://www.npmjs.com/package/casual\"\n      }}><inlineCode parentName=\"a\">{`casual`}</inlineCode></a>{` to solve this, which generates more realistic mock data in useful formats like names, address info, dates, and more.`}</p>\n    <p>{`Add the following mock resolvers to `}<inlineCode parentName=\"p\">{`src/resolvers.js`}</inlineCode>{`:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-diff\"\n      }}>{`    mockResolvers: {\n-     // TODO: Update to mock all schema fields and types.\n-     PFX_YourDataSource: () => ({\n-       id: casual.uuid,\n-       name: casual.name,\n-       lucky_numbers: () => new MockList([0, 3]),\n-     }),\n+     IMDB_Movie: () => ({\n+       cast: () => new MockList([1, 10]),\n+       content_rating: casual.random_element(['PG', 'R', 'PG-13']),\n+       description: casual.sentences(2),\n+       director: casual.name,\n+       genre: () =>\n+         new MockList([1, 3], () =>\n+           casual.random_element(['Action', 'Drama', 'Comedy']),\n+         ),\n+       imdb_id: \\`tt\\${Math.round(10000000 * Math.random())}\\`,\n+       length: \\`\\${casual.integer(75, 190)}\\`,\n+       original_title: casual.title,\n+       rating: casual.integer(0, 100) / 10,\n+       rating_count: casual.integer(0, 300),\n+       release_date: casual.date('YYYY-MM-DD'),\n+       stars: () => new MockList([1, 4], () => casual.name),\n+       storyline: casual.sentences(2),\n+       title: casual.title,\n+       trailer: () => new MockList([1, 3]),\n+       writers: () => new MockList([1, 4], () => casual.name),\n+       year: casual.year,\n+     }),\n    },\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\"><strong parentName=\"p\">{`NOTE:`}</strong>{` For fields that return an array that may vary in length (for\nexample, the number of cast members), we can use Apollo’s `}<a parentName=\"p\" {...{\n          \"href\": \"http://dev.apollodata.com/tools/graphql-tools/mocking.html#Using-MockList-in-resolvers\"\n        }}><inlineCode parentName=\"a\">{`MockList`}</inlineCode></a>{`\nhelper to provide a random-length array. `}<a parentName=\"p\" {...{\n          \"href\": \"http://dev.apollodata.com/tools/graphql-tools/mocking.html#Using-MockList-in-resolvers\"\n        }}>{`See the docs`}</a>{` for more info.`}</p>\n    </blockquote>\n    <h2 {...{\n      \"id\": \"test-the-mock-data-resolvers\"\n    }}>{`Test the Mock Data Resolvers`}</h2>\n    <p>{`Because we don’t actually know (or care) about the `}<em parentName=\"p\">{`actual`}</em>{` response from a mock field (e.g. it doesn’t matter if a mocked name is “Mr. Bentley Tubbinsworth” or “Mrs. Roo Fluffkins”), we’re going to test that:`}</p>\n    <ol>\n      <li parentName=\"ol\">{`The correct mock fields are returned by the mock resolver`}</li>\n      <li parentName=\"ol\">{`Fields that should return a `}<inlineCode parentName=\"li\">{`MockList`}</inlineCode>{` are actually returning `}<inlineCode parentName=\"li\">{`MockList`}</inlineCode>{`s`}</li>\n      <li parentName=\"ol\"><inlineCode parentName=\"li\">{`MockList`}</inlineCode>{`s with custom values are behaving as expected`}</li>\n    </ol>\n    <p>{`To test that the correct fields are returned, we’re going to use the `}{`[`}<inlineCode parentName=\"p\">{`expectMockFields()`}</inlineCode>{` test helper]`}{`({{ site.github.url }}/api/testing/#expectmockfieldsresolver-fieldarray).`}</p>\n    <p>{`To test `}<inlineCode parentName=\"p\">{`MockList`}</inlineCode>{`s, we’ll use the `}{`[`}<inlineCode parentName=\"p\">{`expectMockList()`}</inlineCode>{` test helper]`}{`({{ site.github.url }}/api/testing/#expectmocklistresolver-fieldarray)`}</p>\n    <p>{`Add the following to `}<inlineCode parentName=\"p\">{`test/resolvers.test.js`}</inlineCode>{`:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-diff\"\n      }}>{`    describe('mockResolvers', () => {\n+     describe('IMDB_Movie', () => {\n+       const mockResolvers = resolvers.mockResolvers.IMDB_Movie();\n+\n+       expectMockFields(mockResolvers, [\n+         'cast',\n+         'content_rating',\n+         'description',\n+         'director',\n+         'genre',\n+         'imdb_id',\n+         'length',\n+         'original_title',\n+         'rating',\n+         'rating_count',\n+         'release_date',\n+         'stars',\n+         'storyline',\n+         'title',\n+         'trailer',\n+         'writers',\n+         'year',\n+       ]);\n+\n+       expectMockList(mockResolvers, [\n+         'cast',\n+         'genre',\n+         'stars',\n+         'trailer',\n+         'writers',\n+       ]);\n+\n+       it('mocks the genre', () => {\n+         expect(\n+           ['Action', 'Drama', 'Comedy'].includes(\n+             mockResolvers.genre().wrappedFunction(),\n+           ),\n+         ).toBe(true);\n+       });\n+\n+       it('mocks the stars', () => {\n+         expect(mockResolvers.stars().wrappedFunction()).toBeDefined();\n+       });\n+\n+       it('mocks the writers', () => {\n+         expect(mockResolvers.writers().wrappedFunction()).toBeDefined();\n+       });\n+     });\n    });\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\"><strong parentName=\"p\">{`NOTE:`}</strong>{` The use of `}<inlineCode parentName=\"p\">{`wrappedFunction()`}</inlineCode>{` is a way to get at what the\n`}<inlineCode parentName=\"p\">{`MockList`}</inlineCode>{` returns for a single entry, which allows us to test the value.`}</p>\n    </blockquote>\n    <h2 {...{\n      \"id\": \"add-real-data-resolvers-for-fields-that-require-them\"\n    }}>{`Add Real Data Resolvers for Fields That Require Them`}</h2>\n    <p>{`When we’re using live data, we don’t need to do anything in most cases: the default behavior of GraphQL is to look for a field in the data object that matches the field name in the schema, meaning this schema:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`type PFX_Person {\n  name: String!\n  company: String!\n}\n`}</code></pre>\n    <p>{`And this data response:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n  \"name\": \"Jason Lengstorf\",\n  \"company\": \"IBM\"\n}\n`}</code></pre>\n    <p>{`Will work as-is, with no data resolvers required.`}</p>\n    <p>{`That means that for our IMDB API data source, there’s only one field that requires a data resolver: the `}<inlineCode parentName=\"p\">{`asp_ratio`}</inlineCode>{` field that’s misspelled in the API response.`}</p>\n    <p>{`Let’s add that resolver to `}<inlineCode parentName=\"p\">{`src/resolvers.js`}</inlineCode>{`:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-diff\"\n      }}>{`    dataResolvers: {\n-     // TODO: Update to reference the schema type(s) and field(s).\n-     PFX_YourDataSource: {\n-       // If a field isn’t always set, but it shouldn’t break the response, make it nullable.\n-       name: data => data.name || null,\n-     },\n+     IMDB_Metadata: {\n+       // Alias this field to fix a typo.\n+       asp_ratio: data => data.asp_retio,\n+     },\n    },\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"test-the-data-resolvers\"\n    }}>{`Test the Data Resolvers`}</h2>\n    <p>{`To test the resolver, we need to make sure that it provides the expected value when given an object with the expected data. We get to see the power of using pure functions here again, because all we have to do is give our resolver an object and test what it returns.`}</p>\n    <p>{`Let’s add it by making the following changes in `}<inlineCode parentName=\"p\">{`test/resolvers.test.js`}</inlineCode>{`:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-diff\"\n      }}>{`    describe('dataResolvers', () => {\n-     describe('PFX_YourDataSource', () => {\n-       const resolver = resolvers.dataResolvers.PFX_YourDataSource;\n-\n-       expectNullable(resolver, ['name']);\n-     });\n+     describe('IMDB_Metadata', () => {\n+       const resolver = resolvers.dataResolvers.IMDB_Metadata;\n+\n+       it('fixes the typo for the aspect ratio', () => {\n+         expect(resolver.asp_ratio({ asp_retio: '16 : 9' })).toEqual('16 : 9');\n+       });\n+     });\n    });\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"next-up-use-development-modes\"\n    }}>{`Next Up: Use Development Modes`}</h2>\n    <p>{`At this point, we’ve got a fully functional data source — now we’re ready to test it out.`}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      ","import PageHeader from './PageHeader';\n\nexport default PageHeader;\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport cx from 'classnames';\nimport { pageHeader, withTabs, text } from './PageHeader.module.scss';\n\nconst PageHeader = ({ title, tabs = [] }) => (\n  <div className={cx(pageHeader, { [withTabs]: tabs.length })}>\n    <div className=\"bx--grid\">\n      <div className=\"bx--row\">\n        <div className=\"bx--col-lg-12\">\n          <h1 id=\"page-title\" className={text}>\n            {title}\n          </h1>\n        </div>\n      </div>\n    </div>\n  </div>\n);\n\nPageHeader.propTypes = {\n  /**\n   * Specify the title for the page\n   */\n  title: PropTypes.string,\n};\n\nexport default PageHeader;\n","import EditLink from './EditLink';\n\nexport default EditLink;\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport { graphql, useStaticQuery } from 'gatsby';\n\nimport { link, row } from './EditLink.module.scss';\n\nconst EditLink = ({ relativePagePath, repository: repositoryProp }) => {\n  const {\n    site: {\n      siteMetadata: { repository },\n    },\n  } = useStaticQuery(graphql`\n    query REPOSITORY_QUERY {\n      site {\n        siteMetadata {\n          repository {\n            baseUrl\n            subDirectory\n          }\n        }\n      }\n    }\n  `);\n\n  const { baseUrl, subDirectory } = repositoryProp || repository;\n\n  const href = `${baseUrl}/tree/master${subDirectory}/src/pages${relativePagePath}`;\n\n  return baseUrl ? (\n    <div className={`bx--row ${row}`}>\n      <div className=\"bx--col\">\n        <a className={link} href={href}>\n          Edit this page on GitHub\n        </a>\n      </div>\n    </div>\n  ) : null;\n};\n\nEditLink.propTypes = {\n  repository: PropTypes.shape({\n    baseUrl: PropTypes.string,\n    subDirectory: PropTypes.string,\n  }),\n  relativePagePath: PropTypes.string,\n};\n\nexport default EditLink;\n","import PageTabs from './PageTabs';\n\nexport default PageTabs;\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport { Link } from 'gatsby';\nimport slugify from 'slugify';\nimport cx from 'classnames';\n\nimport {\n  tabsContainer,\n  list,\n  selectedItem,\n  listItem,\n  link,\n} from './PageTabs.module.scss';\n\nexport default class PageTabs extends React.Component {\n  static propTypes = {\n    tabs: PropTypes.array,\n    slug: PropTypes.string,\n  };\n\n  render() {\n    const { tabs, slug } = this.props;\n    const currentTab = slug\n      .split('/')\n      .filter(Boolean)\n      .slice(-1)[0];\n\n    const pageTabs = tabs.map(tab => {\n      const slugifiedTab = slugify(tab, { lower: true });\n      const selected = slugifiedTab === currentTab;\n      const href = slug.replace(currentTab, slugifiedTab);\n      return (\n        <li key={tab} className={cx({ [selectedItem]: selected }, listItem)}>\n          <Link className={link} to={`${href}`}>\n            {tab}\n          </Link>\n        </li>\n      );\n    });\n\n    return (\n      <div className={tabsContainer}>\n        <div className=\"bx--grid\">\n          <div className=\"bx--row\">\n            <div className=\"bx--col-lg-12 bx--col-no-gutter\">\n              <nav>\n                <ul className={list}>{pageTabs}</ul>\n              </nav>\n            </div>\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n","import React from 'react';\nimport slugify from 'slugify';\nimport { useStaticQuery, graphql } from 'gatsby';\n\nimport BackToTopBtn from '../components/BackToTopBtn';\nimport Layout from '../components/Layout';\nimport PageHeader from '../components/PageHeader';\nimport EditLink from '../components/EditLink';\nimport NextPrevious from '../components/NextPrevious';\nimport PageTabs from '../components/PageTabs';\nimport Main from '../components/Main';\n\nconst Default = ({ pageContext, children, location }) => {\n  const { frontmatter = {}, relativePagePath, titleType } = pageContext;\n  const { tabs, title, theme, description, keywords } = frontmatter;\n\n  // get the path prefix if it exists\n  const {\n    site: { pathPrefix },\n  } = useStaticQuery(graphql`\n    query PATH_PREFIX_QUERY {\n      site {\n        pathPrefix\n      }\n    }\n  `);\n\n  // let gatsby handle prefixing\n  const slug = pathPrefix\n    ? location.pathname.replace(pathPrefix, '')\n    : location.pathname;\n\n  const getCurrentTab = () => {\n    if (!tabs) return '';\n    return slug.split('/').slice(-1)[0] || slugify(tabs[0], { lower: true });\n  };\n\n  const currentTab = getCurrentTab();\n  return (\n    <Layout\n      homepage={false}\n      theme={theme}\n      pageTitle={title}\n      pageDescription={description}\n      pageKeywords={keywords}\n      titleType={titleType}\n    >\n      <PageHeader title={title} label=\"label\" tabs={tabs} />\n      {tabs && <PageTabs slug={slug} tabs={tabs} currentTab={currentTab} />}\n      <Main padded>\n        {children}\n        <EditLink relativePagePath={relativePagePath} />\n      </Main>\n      <NextPrevious\n        pageContext={pageContext}\n        location={location}\n        slug={slug}\n        tabs={tabs}\n        currentTab={currentTab}\n      />\n      <BackToTopBtn />\n    </Layout>\n  );\n};\n\nexport default Default;\n"],"sourceRoot":""}