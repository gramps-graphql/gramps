(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{389:function(e,t,n){"use strict";n.r(t),n.d(t,"_frontmatter",(function(){return r})),n.d(t,"default",(function(){return p}));n(11),n(5),n(6),n(2),n(10),n(1),n(0);var a=n(103),o=n(395);function c(){return(c=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}var l,r={},s=(l="PageDescription",function(e){return console.warn("Component "+l+" was not imported, exported, or provided by MDXProvider as global scope"),Object(a.b)("div",e)}),i={_frontmatter:r},b=o.a;function p(e){var t=e.components,n=function(e,t){if(null==e)return{};var n,a,o={},c=Object.keys(e);for(a=0;a<c.length;a++)n=c[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,["components"]);return Object(a.b)(b,c({},i,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)(s,{mdxType:"PageDescription"},Object(a.b)("p",null,"One of the most powerful ways to use GraphQL is to combine two distinct GraphQL schemas, allowing us to create aggregate queries that can load data from multiple back-ends. This is called ",Object(a.b)("a",c({parentName:"p"},{href:"https://www.apollographql.com/docs/graphql-tools/schema-stitching.html"}),"schema stitching"),"."),Object(a.b)("p",null,"In this tutorial, we’ll learn how easy it is to stitch together two GrAMPS data sources.")),Object(a.b)("h2",{id:"part-1-create-a-data-source"},"Part 1: Create a Data Source"),Object(a.b)("p",null,"To get started, let’s create our first data source using the GraphQL CLI"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-bash"}),"# Use npx to run the command without having to install anything globally\nnpx graphql-cli create -b gramps-graphql/data-source-base data-source-stitchingtest\n\n# Move into the folder that was just created\ncd $_\n")),Object(a.b)("p",null,"In ",Object(a.b)("inlineCode",{parentName:"p"},"src/index.js"),", we can declare the entire data source for the sake of simplicity:"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-js"}),"const getContext = (_, __, ctx) => Object.keys(ctx);\n\nexport default {\n  namespace: 'StitchingTest',\n  typeDefs: `\n    type Query {\n      getContext: [String]\n      getById(id: ID!): STX_Test\n    }\n    type STX_Test {\n      id: ID\n      value: String\n    }\n  `,\n  context: {\n    getValue: id => ({\n      id,\n      value: `from StitchingTest with ID “${id}”`,\n    }),\n  },\n  resolvers: {\n    Query: {\n      getContext,\n      getById: (_, { id }, ctx) => ctx.getValue(id),\n    },\n  },\n};\n")),Object(a.b)("p",null,"This data source exposes two queries:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"getContext")," — returns an array of object keys that are present in the data source’s ",Object(a.b)("inlineCode",{parentName:"li"},"context")," object"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"getById")," — exposes ",Object(a.b)("inlineCode",{parentName:"li"},"id")," and ",Object(a.b)("inlineCode",{parentName:"li"},"value")," fields")),Object(a.b)("p",null,"Let’s test this out by running the data source:"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-bash"}),"yarn dev\n")),Object(a.b)("p",null,"At ",Object(a.b)("a",c({parentName:"p"},{href:"http://localhost:8080/playground"}),"http://localhost:8080/playground"),", run the following query:"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-gql"}),"{\n  getContext\n  getById(id: 3) {\n    value\n  }\n}\n")),Object(a.b)("p",null,"We should see the following return value:"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-json"}),'{\n  "data": {\n    "getContext": [\n      "getValue"\n    ],\n    "getById": {\n      "value": "from StitchingTest with ID “3”"\n    }\n  }\n}\n')),Object(a.b)("p",null,"So far so good."),Object(a.b)("h2",{id:"add-local-schema-stitching"},"Add Local Schema Stitching"),Object(a.b)("p",null,"Next, let’s add some schema stitching to the existing data source, just to make sure it’s working the way we expected."),Object(a.b)("p",null,"In ",Object(a.b)("inlineCode",{parentName:"p"},"src/index.js"),", add a ",Object(a.b)("inlineCode",{parentName:"p"},"stitching")," property with the following definitions:"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-js"}),"export default {\n  namespace: 'StitchingTest',\n  typeDefs: `...`,\n  context: { /* ... */ },\n  resolvers: { /* ... */ },\n  stitching: {\n    linkTypeDefs: `\n      extend type Query {\n        getStitchingContext: [String]\n      }\n    `,\n    resolvers: () => ({\n      Query: {\n        getStitchingContext: getContext,\n      },\n    }),\n  },\n};\n")),Object(a.b)("p",null,"Restart the data source in your terminal (",Object(a.b)("inlineCode",{parentName:"p"},"ctrl")," + ",Object(a.b)("inlineCode",{parentName:"p"},"C")," to stop, ",Object(a.b)("inlineCode",{parentName:"p"},"yarn dev")," to start), head to ",Object(a.b)("a",c({parentName:"p"},{href:"http://localhost:8080/playground"}),"http://localhost:8080/playground"),", and run the following query:"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-diff"}),"  {\n    getContext\n+   getStitchingContext\n    getById(id: 3) {\n      value\n    }\n  }\n")),Object(a.b)("p",null,"We should see the following return value:"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-json"}),'{\n  "data": {\n    "getContext": [\n      "getValue"\n    ],\n    "getStitchingContext": [\n      "StitchingTest"\n    ],\n    "getById": {\n      "value": "from StitchingTest with ID “3”"\n    }\n  }\n}\n')),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},Object(a.b)("strong",{parentName:"p"},"NOTE:")," Notice that the contexts are different in ",Object(a.b)("inlineCode",{parentName:"p"},"getStitchingContext"),". This happens because each data source scopes its context to its own namespace to prevent accidentally relying on another data source’s context. However, schema stitching ",Object(a.b)("em",{parentName:"p"},"does")," rely on multiple data source’s contexts, so we include ",Object(a.b)("em",{parentName:"p"},"all")," of the data sources’ contexts.")),Object(a.b)("h2",{id:"add-a-second-data-source"},"Add a Second Data Source"),Object(a.b)("p",null,"Next, let’s create a second data source so we can set up more realistic schema stitching."),Object(a.b)("p",null,"In your terminal, move into the same directory where your first data source was created, then run the following to create a second data source:"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-bash"}),"# Use npx to run the command without having to install anything globally\nnpx graphql-cli create -b gramps-graphql/data-source-base data-source-stitchingtwo\n\n# Move into the folder that was just created\ncd $_\n")),Object(a.b)("p",null,"In ",Object(a.b)("inlineCode",{parentName:"p"},"src/index.js"),", create the second data source all in one place:"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-js"}),"export default {\n  namespace: 'StitchingTwo',\n  typeDefs: `\n    type Query {\n      getSomeValues(val: ID): ST2_Values\n    }\n    type ST2_Values {\n      foo: String\n      bar: String\n      bat: String\n    }\n  `,\n  context: {\n    getSomeValues: val => ({\n      foo: `Schema (val: ${val})`,\n      bar: `Stitching (val: ${val})`,\n      bat: `Rules (val: ${val})`,\n    }),\n  },\n  resolvers: {\n    Query: {\n      getSomeValues: (_, { val }, ctx) => ctx.getSomeValues(val),\n    },\n  },\n};\n")),Object(a.b)("p",null,"This data source is pretty bare bones: it has a single query — ",Object(a.b)("inlineCode",{parentName:"p"},"getSomeValues")," — that exposes three fields that have text and echo the ",Object(a.b)("inlineCode",{parentName:"p"},"val")," the query was called with."),Object(a.b)("p",null,"To test it, let’s fire up the new data source along with the original data source:"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-bash"}),"yarn dev --data-source ../data-source-stitchingtest\n")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},Object(a.b)("strong",{parentName:"p"},"NOTE:")," ",Object(a.b)("inlineCode",{parentName:"p"},"yarn dev")," is shorthand for ",Object(a.b)("inlineCode",{parentName:"p"},"gramps dev --data-source ."),", so what we’re doing here is effectively running ",Object(a.b)("inlineCode",{parentName:"p"},"gramps dev --data-source . --data-source ../data-source-stitchingtest"))),Object(a.b)("p",null,"Open ",Object(a.b)("a",c({parentName:"p"},{href:"http://localhost:8080/playground"}),"http://localhost:8080/playground")," and update the query to call ",Object(a.b)("inlineCode",{parentName:"p"},"getSomeValues"),":"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-diff"}),"  {\n    getContext\n    getStitchingContext\n    getById(id: 3) {\n      value\n    }\n+   getSomeValues(val: 2) {\n+     foo\n+     bar\n+     bat\n+   }\n  }\n")),Object(a.b)("p",null,"The output should be:"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-json"}),'{\n  "data": {\n    "getContext": [\n      "getValue"\n    ],\n    "getStitchingContext": [\n      "StitchingTwo",\n      "StitchingTest"\n    ],\n    "getById": {\n      "value": "from StitchingTest with ID “3”"\n    },\n    "getSomeValues": {\n      "foo": "Schema (val: 2)",\n      "bar": "Stitching (val: 2)",\n      "bat": "Rules (val: 2)"\n    }\n  }\n}\n')),Object(a.b)("h2",{id:"use-schema-stitching-to-combine-the-two-data-sources"},"Use Schema Stitching to Combine the Two Data Sources"),Object(a.b)("p",null,"Finally, let’s add ",Object(a.b)("inlineCode",{parentName:"p"},"stitching")," config to tie the two data source together. In the second data source, add the following:"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-js"}),"export default {\n  namespace: 'StitchingTwo',\n  typeDefs: `...`,\n  context: { /* ... */ },\n  resolvers: { /* ... */ },\n  stitching: {\n    linkTypeDefs: `\n      extend type STX_Test {\n        stitched: ST2_Values\n      }\n    `,\n    resolvers: mergeInfo => ({\n      STX_Test: {\n        stitched: {\n          fragment: 'fragment StitchingTestField on STX_Test { id }',\n          resolve: ({ id }, args, context, info) =>\n            mergeInfo.delegate(\n              'query',\n              'getSomeValues',\n              { val: id },\n              context,\n              info,\n            ),\n        },\n      },\n    }),\n  },\n};\n")),Object(a.b)("p",null,"First, we use ",Object(a.b)("inlineCode",{parentName:"p"},"linkTypeDefs")," to extend the ",Object(a.b)("inlineCode",{parentName:"p"},"STX_Test")," type by adding a new field called ",Object(a.b)("inlineCode",{parentName:"p"},"stitched"),"."),Object(a.b)("p",null,"Then, in ",Object(a.b)("inlineCode",{parentName:"p"},"resolvers"),", we set up ",Object(a.b)("inlineCode",{parentName:"p"},"stitched")," — which is a field on our first data source, remember — to get its value from the ",Object(a.b)("inlineCode",{parentName:"p"},"getSomeValues")," query, which is in the second data source."),Object(a.b)("p",null,"Under the hood, this is done using ",Object(a.b)("a",c({parentName:"p"},{href:"https://www.apollographql.com/docs/graphql-tools/schema-stitching.html#mergeSchemas"}),Object(a.b)("inlineCode",{parentName:"a"},"mergeSchemas")),". Be sure to check that out for additional information about how schema stitching happens, and some of the different ways you can work with it."),Object(a.b)("p",null,"With the stitching config in place, let’s fire it up and test it."),Object(a.b)("p",null,"Run the following command to start a gateway with both data sources:"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-bash"}),"yarn dev --data-source ../data-source-stitchingtest\n")),Object(a.b)("p",null,"Then, open ",Object(a.b)("a",c({parentName:"p"},{href:"http://localhost:8080/playground"}),"http://localhost:8080/playground")," and add the ",Object(a.b)("inlineCode",{parentName:"p"},"stitching")," field to the query:"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-diff"}),"  {\n    getContext\n    getStitchingContext\n    getById(id: 3) {\n      value\n+     stitched {\n+       foo\n+       bar\n+       bat\n+     }\n    }\n    getSomeValues(val: 2) {\n      foo\n      bar\n      bat\n    }\n  }\n")),Object(a.b)("p",null,"Once executed, we’ll see the following:"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-json"}),'{\n  "data": {\n    "getContext": [\n      "getValue"\n    ],\n    "getStitchingContext": [\n      "StitchingTwo",\n      "StitchingTest"\n    ],\n    "getById": {\n      "value": "from StitchingTest with ID “3”",\n      "stitched": {\n        "foo": "Schema (val: 3)",\n        "bar": "Stitching (val: 3)",\n        "bat": "Rules (val: 3)"\n      }\n    },\n    "getSomeValues": {\n      "foo": "Schema (val: 2)",\n      "bar": "Stitching (val: 2)",\n      "bat": "Rules (val: 2)"\n    }\n  }\n}\n')),Object(a.b)("p",null,"And that’s it! We now have one data source including data from a second data source as part of its own queries."))}p.isMDXComponent=!0},393:function(e){e.exports=JSON.parse('{"data":{"site":{"pathPrefix":""}}}')},394:function(e){e.exports=JSON.parse('{"data":{"site":{"siteMetadata":{"repository":{"baseUrl":"","subDirectory":""}}}}}')},395:function(e,t,n){"use strict";n(35),n(27);var a=n(1),o=n(393),c=n(0),l=n.n(c),r=n(102),s=n.n(r),i=n(188),b=n(121),p=n(3),u=n.n(p),d=n(373),h=function(e){var t,n=e.title,o=e.tabs,c=void 0===o?[]:o;return Object(a.b)("div",{className:u()(d.pageHeader,(t={},t[d.withTabs]=c.length,t))},Object(a.b)("div",{className:"bx--grid"},Object(a.b)("div",{className:"bx--row"},Object(a.b)("div",{className:"bx--col-lg-12"},Object(a.b)("h1",{id:"page-title",className:d.text},n)))))},g=n(394),m=n(374),j=function(e){var t=e.relativePagePath,n=e.repository,o=g.data.site.siteMetadata.repository,c=n||o,l=c.baseUrl,r=l+"/tree/master"+c.subDirectory+"/src/pages"+t;return l?Object(a.b)("div",{className:"bx--row "+m.row},Object(a.b)("div",{className:"bx--col"},Object(a.b)("a",{className:m.link,href:r},"Edit this page on GitHub"))):null},O=n(186),f=n(28),y=n(375);var N=function(e){var t,n;function o(){return e.apply(this,arguments)||this}return n=e,(t=o).prototype=Object.create(n.prototype),t.prototype.constructor=t,t.__proto__=n,o.prototype.render=function(){var e=this.props,t=e.tabs,n=e.slug,o=n.split("/").filter(Boolean).slice(-1)[0],c=t.map((function(e){var t,c=s()(e,{lower:!0}),l=c===o,r=n.replace(o,c);return Object(a.b)("li",{key:e,className:u()((t={},t[y.selectedItem]=l,t),y.listItem)},Object(a.b)(f.Link,{className:y.link,to:""+r},e))}));return Object(a.b)("div",{className:y.tabsContainer},Object(a.b)("div",{className:"bx--grid"},Object(a.b)("div",{className:"bx--row"},Object(a.b)("div",{className:"bx--col-lg-12 bx--col-no-gutter"},Object(a.b)("nav",null,Object(a.b)("ul",{className:y.list},c))))))},o}(l.a.Component),v=n(187);t.a=function(e){var t=e.pageContext,n=e.children,c=e.location,l=t.frontmatter,r=void 0===l?{}:l,p=t.relativePagePath,u=t.titleType,d=r.tabs,g=r.title,m=r.theme,f=r.description,y=r.keywords,w=o.data.site.pathPrefix,x=w?c.pathname.replace(w,""):c.pathname,S=d?x.split("/").slice(-1)[0]||s()(d[0],{lower:!0}):"";return Object(a.b)(b.a,{homepage:!1,theme:m,pageTitle:g,pageDescription:f,pageKeywords:y,titleType:u},Object(a.b)(h,{title:g,label:"label",tabs:d}),d&&Object(a.b)(N,{slug:x,tabs:d,currentTab:S}),Object(a.b)(v.a,{padded:!0},n,Object(a.b)(j,{relativePagePath:p})),Object(a.b)(O.a,{pageContext:t,location:c,slug:x,tabs:d,currentTab:S}),Object(a.b)(i.a,null))}}}]);
//# sourceMappingURL=component---src-pages-data-sources-schema-stitching-mdx-65073141d3e641718e16.js.map